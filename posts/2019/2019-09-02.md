# 2019년 9월 2일

## Firestore 인덱싱 에러

현재 회사에서 맡고 있는 프로젝트의 메이저 버전을 올리는 과정에서 여러 기능들이 새로 추가되었고, 이에 따라 프로젝트에서 사용 중인 Firestore의 DB 구조에도 몇 가지 변경사항이 생겼다. 그 과정 속에서 전에 경험해보지 못 했던 새로운 문제들이 생겨났는데, 가장 해결이 힘들었던 문제 중 하나는 인덱싱 관련 에러였다. 에러 메세지의 내용은 다음과 같았다.

> Too many builtin index entries for entity.

이 문제가 해결하기 힘들었던 이유는 일단 에러 메세지를 봐도 무슨 말인지 이해를 못 했다. 결국 문서를 다시 천천히 읽어보고 나서야 Firestore에서 기본적으로 모든 문서의 필드에 대해 기본 색인을 생성해준다는 걸 알 수 있었다. 그런데 결국 이 문제를 해결하려면 현재 사용하고있는 Firestore DB 구조를 변경해야 했고, 기존에 쌓여있는 데이터와의 호환성도 고려해야했기 때문에 문제가 그리 간단하지 않았다.

결국 기존 데이터를 모두 새 구조에 맞게 마이그레이션하는 게 가장 좋은 방법이라고 판단했다. 그런데 나는 Firestore DB 마이그레이션 방법에 대해 모르는 상태였으므로 이마저도 쉬운 일이 아니었다. 하는 수 없이 방법을 찾아보다가 Firestore DB도 이제 import / export를 지원한다는 내용을 발견했고, 이 기능을 이용하면 어찌되었든 마이그레이션이 가능할거란 생각이 들었다.(분명 예전엔 지원하지 않았던 걸로 기억하는데 비교적 최근에 추가된 듯 하다.)

그런데 이를 위해선 GCP에서 Firestore에 대한 수정 권한도 부여해야하는 등 이것저것 몇 가지 절차가 추가적으로 필요했다. 이미 밤을 새가며 진이 빠질대로 빠져서 빡쳐있었던 나는 더 이상 문서를 차근차근 읽을 힘도 남아있지 않은 상황.. 차라리 그냥 노가다로 일괄 쓰기 작업을 진행하는게 빠를 수도 있겠다 싶어서 결국 후자의 방법을 선택했다.

다행히도 이 방법으로 급한 문제는 해결됐다. 혹시나 똑같은 문제가 재발하고 있진 않은 지 Sentry를 열심히 모니터링해야겠다. 또 다시 문제가 생긴다면, 이번에는 해당 컬렉션에 속한 문서들에 대한 기본 색인 생성을 막아볼 생각이다.

이 문제를 해결하면서 나는 다음 두 가지를 배울 수 있었다.

1. 이번에 겪었던 에러를 똑같이 겪지 않으려면 DB 구조를 어떻게 설계해야하는지 확실히 알게 됐다.
2. 이번엔 비록 문서 읽는 게 귀찮아서 노가다로 처리했지만, Firestore DB 마이그레이션을 어떻게 할 수 있을 지 알게 됐다.

## 오늘 읽은 글

* [Index types in Cloud Firestore | Firebase](https://firebase.google.com/docs/firestore/query-data/index-overview?authuser=1#single-field_index_exemptions)
